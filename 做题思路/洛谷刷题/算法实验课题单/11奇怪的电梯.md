# P1135 奇怪的电梯

## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？

## 输入格式

共二行。  

第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \le N \le 200$，$1 \le A, B \le N$）。

第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。

## 输出格式

一行，即最少按键次数，若无法到达，则输出 `-1`。

## 输入输出样例 #1

### 输入 #1

```
5 1 5
3 3 1 2 5
```

### 输出 #1

```
3
```

## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。

![alt text](image-1.png)


***OK啊孩子们这个题可以说是非常全面了，让我们看看是怎么一步步学到很多东西的***

# 一道夯爆了的图论＋搜索题的学习笔记
(扩展，能否找到最短路输出？)
## 题目初尝试


### 暴力dfs
```
我的思路是这样，可以用深度和广度优先，这里先用深度，
先把给到的每层数字记录在数组中，这里数组我们使用1-based，然后使用dfs，
这里因为可能到不了，以及防止循环，需要用一个visited数组记录每一层是否到达，


dfs函数我们这样写，接受两个参数，从哪一层到哪一层，返回所需的最少次数，
到达不了则返回0x3f3f3f3f,方便以后的最小值判断，

首先考虑两个方向，返回dfs最小值+1（即min(dfs(cur + k[cur],tar),dfs(cur - k[cur],tar)+1），填入对应参数，这里visited数组作为全局数组，
表示到一次就不用考虑了，对于一次查询这是合理的，（另外，这里你可以告诉我怎么处理多次查询?在每次查询后重置visited数组吗），

如果cur（第一个参数）== tar，即可以返回1，表示按一次可以到.

最后在主函数中调用dfs(a,b)即可
```
#### 小插曲
在解决记忆化之前，我们来看看原始代码中可以学习的地方
```c++
int dfs(int cur, int tar){
    if (cur == tar) return MAX;
    if (cur <= 0 || cur > n) return MAX;
    if (memo[cur][tar] != MAX) return memo[cur][tar];
    memo[cur][tar] =  min(dfs(cur + k[cur], tar),dfs(cur - k[cur], tar) + 1);
    return memo[cur][tar];
}
```
这个是初始版本，因为最初觉得memo数组可以代替visited，就直接这样写了，来看看问题
1.b是全局变量，可以直接优化一个参数
2.memo不可以代替visited,当时的主观思路，我想现在不用解释了
3.如果两个都不满足，返回其实是MAX + 1，虽然后续也可以判断，但是MAX表示的其实是不可达，MAX + 1反而表示一个很大值，所以为了明确含义，我们更好的方式是这样写
```c++
int up = cur + k[cur];
int down = cur - k[cur];//变量代替坐标更清晰
int best = MAX;
int up_ans = (up > n) ? MAX : dfs(up);
int down_ans = (down < 1) ? MAX : dfs(down);
//这里如果用if判断然后比较的话会增加dfs调用，所以用变量up_ans储存起来再用到best上
if (up_ans != MAX) best = min(best, up_ans);
if (down_ans != MAX) best = min(best, down_ans);
memo[cur] = best;

```
4.
```c++
cout << (ans >= MAX / 2) ? -1 : ans;
```
你敢想这个是错的吗，还是都加上括号稳(<<优先级更高)

5.问题来了，visited数组可能会阻止不同路径，尤其是先走的那条路径返回值是max,这时候真正的最短路会被visited阻塞，（这里其实就能意识到用bfs更好了，或者说看到最短路就该用bfs）
所以最终修改版是这样
（尝试一下，是否能自己举出反例？）
```c++
int dfs(int cur){
    if (visited[cur] == 1) return MAX;
    if (cur == b) return 0;
    if (memo[cur] != -1) return memo[cur];

    visited[cur] = 1;//框架

    int up = cur + k[cur];
    int down = cur - k[cur];
    int up_ans = (up <= n) ? dfs(up) : MAX;
    int down_ans = (down > 0) ? dfs(down) : MAX;
    int best = MAX;
    if (up_ans != MAX) best = min(best, up_ans + 1);
    if (down_ans != MAX) best = min(best, down_ans + 1);
    memo[cur] =  best;

    visited[cur] = 0;//回溯

    return memo[cur];
}
```
![alt text](image-3.png)

这里基本思路其实是对的，但是不memo贴上去会tle，邪恶的AI提示我们用memo数组来记忆化，来看看问题在哪

对照上面的代码，不妨举几个例子，其实很难举，在国产各个AI全举不出来以及gpt在样例帮助下才举出来，其实是这样的

a = 4,b = 1,这里的3由于第一个圈4-5-6-2-3被标记为MAX了
![alt text](22e4bfc80df671b8c7dd836ae91a0047.jpg)

问题不是memo数组或者visited数组，而是二者的联合作用，在visited的特定情况下，memo数组会错误的把某些位置记错，其实这只是这条路径下的问题，这就涉及到下面要说的了

### dfs剪枝模拟bfs
visited数组的作用是防止环，但其实我们应该也可以想到防止环还有一种方式，就是通过长度剪枝，如果现在得到的长度比之前储存的长度还要长，那就没有更新的必要了。
代码如下：
```c++
if (up <= n && dist[cur] + 1 < dist[up]) {
    ...//dist[x]表示当前x到a的最短距离
}
```
用dist数组的判断来代替visited数组避免环，我们就可以得到一版新的代码
```c++
int dfs(int cur){//dfs[cur]表示cur节点到b的最短路径
    if (cur == b) return 0;
    if (k[cur] == 0) return MAX;
    int up = cur + k[cur];
    int down = cur - k[cur];
    int up_ans = MAX, down_ans = MAX;
    if (up <= n && dist[up] > dist[cur] + 1) {
        dist[up] = dist[cur] + 1;//注意更新时机
        up_ans = dfs(up);
    }
    if (down > 0 && dist[down] > dist[cur] + 1) {
        dist[down] = dist[cur] + 1;
        down_ans = dfs(down);
    }
    int best = MAX;
    if (up_ans != MAX) {
        best = min(best, up_ans + 1);
    }
    if (down_ans != MAX ) {
        best = min(best, down_ans + 1);
    }
    return best;
}
```
其实还可以更简化，因为dist数组就可以代表a到任何点的距离了，所以函数可以不需要返回值，直接输出dist[b]，同时，这时的dfs可以用手动压栈代替了

![alt text](image-4.png)
那么我们很容易联想到，dist数组和我的memo数组有什么区别呢?我们直接用memo数组也不要visited数组能不能实现呢?
关键在dist[a] = 0;这样dist[cur] + 1 < dist[next]是可以判断的了，所以如果是memo，我们就需要反向遍历，这个时候其实两个数组就是等价的了，memo[b] = 0,来看看gpt怎么说
![alt text](image-5.png)


OK，现在是这一部分的总结
|序号|细节关键点|重要程度|序号|模版关键点|重要程度|
|---|---|---|---|---|---|
|1|边界(up >= 1而不是0)|⭐⭐|11|visited在dfs中的回溯模版|⭐⭐|
|2|答案是全局变量，可以优化参数|⭐|22|memo和visited同时存在时<br>由于状态依赖导致的错误|⭐⭐|
|3|cout和?的优先级|⭐|33|dfs通过dist剪枝模拟bfs|⭐|
|4|dist的更新时机|⭐|44|MAX返回值的优化写法|⭐⭐|


![alt text](image-6.png)
![alt text](image-7.png)
（我是来分割的）


## 正确想法：BFS
代码是好写的，注意一定要visited,关键：
```c++
visited[a] = 1;
```
这很重要
还有就是，visited的标记时机
```c++
    int cur = q.front();
    if (cur == b) {
        flg = 1;
        break;
    }
    q.pop();
    visited[cur] = 1;
    int up = cur + k[cur];
    int down = cur - k[cur];
    if (up <= n && !visited[up]) q.push(up);
    if (down >= 1 && !visited[down]) q.push(down);
```
这样会导致很多重复，入队时就应该标记
```c++
if (){
    visited[up] = 1;
    q.push(up);
}
```
同时，找到了最好直接返回，不然break后在下面ans--这样修正可能麻烦
```c++
if (cur == b) {
    cout << ans;//ans在外层循环中，每层递增
    return 0;
}
```
最后，这里一直错，因为没有用MAX,所以没在意返回值，注意无解时返回-1

总结一下bfs的点
|序号|关键点|重要性|
|---|---|---|
|1|visited数组的初始点|⭐⭐⭐|
|2|wisited的标记时机（入队）|⭐⭐|
|3|得到答案和无解的处理|⭐|

![alt text](image-8.png)
![alt text](image-9.png)
## 其他通过这道题复习的乱七八糟的做法
首先，把这道题建模成等权有向图的单源最短路就是个本事
### dijkstra

首先复习一下什么是dijkstra

每次找到   ***未访问过的***   ***最近点***
通过它来松弛其他边

显然，我们需要用队列来储存访问过的邻居（不然你不会想每次都遍历吧）
而且，我们要用的是最短的，所以自然想到小顶堆
虽然没啥用但是还是说一下时间复杂度是o((m + n)logn),m是边，n是点，对应push和pop，这两个操作都需要堆用logn来调整

需要注意的点：
小顶堆写法是：
```c++
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>q;
```

因为第一个是比较对象，所以要变成{step,cur}，不要写反

同时，注意这里还有一个点，就是
```c++
if (step > dist[cur]) continue;
```
在更新过程中，原先进队的点可能已经不够优了

最后写一下模版
```c++
q.push({0,a});
while (!q.empty()) {
    auto [step, cur] = q.top();
    q.pop();
    if (cur == b) {
        ···
    }
    if (step > dist[cur]) continue;

    int up···
    if (up <= n && dist[cur] + 1 < dist[up]) {
        dist[up] = dist[cut] + 1;
        q.push({dist[up],up});
    }
}
```

总结一下
|序号|关键点|重要程度|
|---|---|---|
|1|小顶堆写法|⭐⭐|
|2|排序对二元组的要求|⭐⭐|
|3|dijkstra更新时的剪枝|⭐|
|4|dijkstra模版|⭐⭐|

### 双向bfs
思考：
q1:
```
普通 BFS 从 起点 单向扩展，大概要探索多少个节点（用 k 和 d 表示）？
```
ans1:
```
我们只需要搜索一个终点，所以可以两边同时搜索来减小范围，因为
k^d + k^d 远小于 k^(2d)
```

q2:
```
当两个 BFS 的“搜索边界”相遇时，是否意味着找到了最短路？为什么？
```
ans2:
```
是的，因为左边最短，右边也最短
```

q3:
```
在双向 BFS 中，我们为什么要 每次扩展较小的队列？
如果我们不用 “小队列优先”，会发生什么？
```

ans3:
```
可以平均两边的拓展次数，如果不优先小队列，可能退化成单向bfs
```

q4:
```
判断中止是左边等于右边（但是这里怎么写呢，单向bfs里是cur = target,只需要维护一个cur,双向难道要cur1 = cur2吗，那岂不是要嵌套两层循环，左边一层中的每一个匹配右边的一层）
```

ans4:
```
当左边扩散时，只要它遇到一个“右边已经访问过的节点”，就说明路径相遇了

想象两个人从 A 和 B 同时往中间走。
不是等走到同一个点才算相遇，而是：
只要左边走到一个点，这个点已经被右边走过了，就已经“遇到”了！
```

q5:
```
我记得之前这个不用按层(最大食物链)
```

ans5:
| 算法                | 必须按层扩展吗？ | 原因               |
| ----------------- | -------- | ---------------- |
| **普通 BFS（无权最短路）** | **必须**   | 保证最短路            |
| **双向 BFS**        | **必须**   | 控制扩展范围、保持最短路两边同步 |
| **拓扑排序（DAG BFS）** | **不需要**  | 只要前驱先处理，不需要最短路   |

![alt text](image.png)
| 条件                 | 是否必须   | 说明        |
| ------------------ | ------ | --------- |
| **无权图或等权图**        | ✔ 必须   | BFS 才是最短路 |
| **图可逆（至少终点能逆向扩展）** | ✔ 几乎必须 | 无向图最适合    |
| **有单一起点 + 单一终点**   | ✔ 必须   | 才能双向逼近    |
| **搜索空间大且深**        | 推荐     | 才能体现优势    |


下面给出模版代码
```c++
#include<bits/stdc++.h>
using namespace std;
int bidirection_bfs(int start, int target, vector<vector<int>> &adj){
    if (start == target) return 0;
    int n = adj.size();
    queue<int> qa, qb;
    vector<int> da(n, -1);
    vector<int> db(n, -1);
    da[start] = 0;
    db[target] = 0;
    qa.push(start);
    qb.push(target);
    while (!qa.empty() && !qb.empty()) {
        if (qa.size() <= qb.size()) {
            //扩展左边
            int size = qa.size();
            while (size--) {
                int cur = qa.front();
                qa.pop();
                for (int next : adj[cur]) {
                    if (da[next] == -1) {
                        da[next] = da[cur] + 1;
                        qa.push(next);
                        if (db[next] != -1) {
                            return db[next] + da[next];
                        }
                    }
                }
            }

        }
        else{
            //扩展右边
            int size = qb.size();

            while (size--) {
                int cur = qb.front();
                qb.pop();
                for (int next : adj[cur]) {
                    if (db[next] == -1) {
                        db[next] = db[cur] + 1;
                        qb.push(next);
                        if (da[next] != -1) {
                            return db[next] + da[next];
                        }
                    }
                }
            }
        }
    }
    return -1;
}
```

关键逻辑
```c++
if (qa.size() <= qb.size()) {
    int size = qa.size();
    while (size--) {
        int cur = qa.front();
        qa.pop();
        for (int next: adj[cur]) {
            if (da[next] == -1) {
                da[next] = da[cur] + 1;
                qa.push(next);
                if (db[next] != -1) {
                    return da[next] + db[next];
                }
            }
        }
    }
}
```

### bellman-ford
🧩 1. 我们先从一个最简单的问题开始：

如果图中没有负权边，怎么求单源最短路径？

你会想到：

BFS（只适用于等权图）

Dijkstra（适用于正权图）

但为什么 Dijkstra 不能处理负权？

因为 Dijkstra 的关键逻辑是：

当你把最小 dist 的节点弹出时，这个 dist 是最终值。

但如果有负权，你弹出来后可能被其他路径继续变小 → 破坏正确性。

所以：
👉 我们需要一个能处理负权的算法。

2.算法理解：
算法第k轮得到的是k条边到原点的准确最短路径，不是层序，别的也可能被更新，但不一定是最短的，v-1轮可以保证所有路径都是最短的

直接上代码
```c++
#include<bits/stdc++.h>
using namespace std;
struct Edge{
    int u, v, w;
};
vector<Edge>edges;
int bellman_ford(int start, int target) {
    int n, m;
    cin >> n >> m; 
    const int MAX = 0x3f3f3f3f;
    vector<int>dist(n + 1, MAX);
    dist[start] = 0;
    edges.resize(m);
    for (int i = 0; i < m; i++) {
        cin >> edges[i].u >> edges[i].v >> edges[i].w;
    }
    for (int i = 1; i <= n - 1; i++) {
        for (auto &e: edges) {
            if (dist[e.u] != MAX) dist[e.v] = min(dist[e.v], dist[e.u] + e.w);
        }
    }
    return dist[target];
}
```

```c++
可以优化：
bool updated = false;
for (int i = 1; i <= n - 1; i++) {
    updated = false;
    for (auto &e : edges) {
        if (dist[e.u] != MAX && dist[e.u] + e.w < dist[e.v]) {
            dist[e.v] = dist[e.u] + e.w;
            updated = true;  // 本轮有更新
        }
    }
    if (!updated) break;  // 无更新，可提前结束
}

```

然后是判断负环
```c++
// 检测负环
for (auto &e : edges) {
    if (dist[e.u] != MAX && dist[e.u] + e.w < dist[e.v]) {
        cout << "Negative Cycle Detected\n";
        return -1;
    }
}

```

加入前驱返回路径
```c++
vector<int> restore_path(int start, int target, vector<int> &pre, vector<int> &dist) {
    const int INF = 0x3f3f3f3f;
    vector<int> path;

    if (dist[target] == INF) return path;  // 无路径，返回空

    int cur = target;
    while (cur != -1) {
        path.push_back(cur);
        if (cur == start) break;   // 到达起点
        cur = pre[cur];
    }

    reverse(path.begin(), path.end());
    return path;
}

```
|序号|关键点|重要程度|
|---|---|---|
|1|初始值start的初始化|⭐⭐|
|2|注意松弛顺序|⭐|
|3|i < n - 1是点n而不是边m|⭐|
|4|确保可达|⭐|
|5|优化|⭐|
|6|while中保留start一块的学习|⭐|
|7|前驱来获得路径|⭐⭐|

### SPFA
