# P1434 [SHOI2002] 滑雪

## 题目描述

Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：
```plain
1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  12  11  10  9
```
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24-17-16-1$（从 $24$ 开始，在 $1$ 结束）。当然    $25$－$24$－$23$－$\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。

## 输入格式

输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度（两个数字之间用 $1$ 个空格间隔）。

## 输出格式

输出区域中最长滑坡的长度。

## 输入输出样例 #1

### 输入 #1

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

### 输出 #1

```
25
```

## 说明/提示

对于 $100\%$ 的数据，$1\leq R,C\leq 100$。

```
首先，我的一个思路是，
先找到整个图中最小的值，只有他的值是唯一确定的，
他的dp数组设为1，
然后开始用bfs算法通过队列依次确定，
如果能扩展dp值就加一，并且取最大值，
当然这样一遍完成后并不是最终解，
我的思路本来是从另一边再BFS一遍，但是现在发现这是特例，
这个BFS一次不能达到最优解的问题该如何解决呢，
把第一次的路径记录下来再反向？
感觉有点难实现
```

这一次AI的答复是

![alt text](image.png)

```
我听懂你的想法了，先总结一下现在的思路：
1.BFS一般用于无权图的最短路径
2.在这道题中，二维数组其实可以通过与邻居间的高度关系转化为DAG
3.我在刚才其实已经意识到要从小的开始往大的拓展，但是担心排序会破坏图的结构，
  所以只做出了找最小值这一个小优化，但是其实可以通过排序带来的顺序来进行拓展
4.但是这里为什么还要在加上一个邻居高度小于他的判断而不是直接修改邻居而是修改本身呢，
如果写成if(邻居 高于 [i][j]){dp[邻居] = dp[i][j] + 1}，能达到最优解吗，
我们思考一下，我试了几个例子，都是正确的，你能举出来反例吗
```

这里AI回答等价

```C++
好的，既然你这么说了，我们把主要思路的代码写出来，
首先，不考虑输入，放到后面再补充
关键语句:1.诶，怎么把二维数组变成一维的啊，我先试试吧,sort(grid.begin(),
OK,写了一半去问ai，发现不行，这样排的是行之间的字典序，
两种方法，第一种拉平，第二种用堆，来都写一下：
    vector<int>all;
    for (auto row : grid) {
        for (int x : row) {
            all.push_back(x);
        }
    }
    sort(all.begin(),all.end());
然后是堆，注意堆第二个参数是vector<int>，第三个参数是比较方法，
突然发现了问题，这里我需要保存的是点的坐标，但排序的是它的值，
真有点想用结构体了，不过还有别的方法，
一是用三元组，但是更常用的是自定义比较函数
```



|序号|值得注意的点|
|---|---|
|1|BFS的使用场景，可以总结|
|2|DAG的构造|
|3|排序破坏顺序，可以只按顺序遍历|
|4|本题的正反向的顺序|
|5|如何排序遍历二维数组|
|6|堆的参数|
|7|保存坐标和实际是值排序的三种方法|
|8|边界有效的判断|